#include "synt_analyzer.h"

// функция проверяет, является ли строка токенов синтаксически корректной
int synt_analyzer(std::string str)
{
	// таблица переходов автомата с магазинной памятью
	// {q, S}
	// q - состояние в которое должен перейти автомат (-1 - ошибочное состояние, 15 - допускающее состояние, -2 - переход в состояние, находящееся на вершине стека)
	// S - состояние, которое необходимо добавить в стек(-1, -2 - заглушка)
	state states[13][7] = {{{2, 1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 0
						   {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {15, -1}},	// 1
						   {{3, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 2
						   {{-1, -1}, {4, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 3
						   {{-1, -1}, {-1, -1}, {5, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 4
						   {{2, 8}, {6, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},		// 5
						   {{-1, -1}, {-1, -1}, {-1, -1}, {7, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 6
						   {{-1, -1}, {8, -1}, {-1, -1}, {-1, -1}, {8, -1}, {-1, -1}, {-1, -1}},	// 7
						   {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {9, -1}, {-2, -2}},	// 8
						   {{2, 12}, {10, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 9
						   {{-1, -1}, {-1, -1}, {-1, -1}, {11, -1}, {-1, -1}, {-1, -1}, {-1, -1}},	// 10
						   {{-1, -1}, {12, -1}, {-1, -1}, {-1, -1}, {12, -1}, {-1, -1}, {-1, -1}},	// 11
						   {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}, {-2, -2}, {-2, -2}}}; // 12

	std::stack<int> stack;	   // инициализируем стек
	int qpre = 0;			   // предыдущее состояние автомата
	int q = 0;				   // текущее состояние автомата
	int ind = 0;			   // текущий, разбираемый токен
	while (q != -1 && q != 15) // цикл, выполняющий перебор токенов, до допускающего состояния или ошибки
	{
		qpre = q;							 // сохраняем предыдущее состояние автомата
		q = states[q][toktonum(str[ind])].q; // присваиваем новое состояние
		if (q == 2)
			stack.push(states[qpre][toktonum(str[ind])].S); // если состояние равно 2, то необходимо добавить в стек значение S предыдущуго состояния
		else if (q == -2)
		{
			q = stack.top(); // если состояние равно -2, то ивлекаем из стека значение и присваиваем его текущему состоянию
			stack.pop();
		}
		else
			ind++; // переходим к следующему токену
	}
	if (q == 15 && ind == str.length()) // если пришли в допускающее состояние, строка распознана
		return 0;
	return -1; // иначе не распознана
}

// функция преобразует токен в номер столбца таблицы переходов автомата
int toktonum(char token)
{
	switch (token)
	{
	case 'f':
		return 0;
		break;
	case 'i':
		return 1;
		break;
	case 't':
		return 2;
		break;
	case 'a':
		return 3;
		break;
	case 'n':
		return 4;
		break;
	case 'e':
		return 5;
		break;
	case ';':
		return 6;
		break;
	default:
		return -1;
		break;
	}
}
